use anyhow::{Result};
// use log::{error, info};
// use metaboss_lib::decode::*;
// use mpl_token_metadata::state::{Creator, Data};
// use mpl_token_metadata::{
//     instruction::{
//         update_metadata_accounts_v2,
//     },
//     ID as TOKEN_METADATA_PROGRAM_ID,
// };
// use rayon::prelude::*;
use retry::{delay::Exponential, retry};
// use serde::Serialize;
// use serde_json::Value;
use solana_client::rpc_client::RpcClient;
use solana_sdk::{
    pubkey::Pubkey,
    signature::{Signature, read_keypair_file},
    signer::{keypair::Keypair, Signer},
    system_instruction::create_account,
    transaction::Transaction,
    system_program::{
        ID as SYSTEM_PROGRAM_ID,
    },
    sysvar::rent::{
        ID as RENT_PUBKEY,
    }
};
use spl_associated_token_account::{
    get_associated_token_address,
    create_associated_token_account,
};
use spl_token::{
    instruction::{initialize_mint},
    ID as TOKEN_PROGRAM_ID,
};
use std::{str::FromStr, rc::Rc};
use anchor_client::{Client, Cluster};
// The `accounts` and `instructions` modules are generated by the framework.
use kycdao_ntnft::accounts as kycdao_ntnft_accounts;
use kycdao_ntnft::instruction as kycdao_ntnft_instruction;

pub const METAPLEX_PROGRAM_ID: &str = "metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s";
pub const KYCDAO_PROGRAM_ID: &str = "391aDmre352WhEtdpuMqHHwJxjvDRF4zu3pEKi6KRBzC";
pub const RECEIVER_ADDR: &str  = "F2bYxvcmSpuX3kGEPSfJic4yL5uu6PumoobR6bkyp6sM";
const MINT_LAYOUT: u64 = 82;

fn main() -> Result<()> {
    println!("Running prepare_mint...");
    let client = RpcClient::new("https://api.devnet.solana.com".to_string());
    let funder = read_keypair_file(&*shellexpand::tilde("~/.config/solana/id.json"))
        .expect("Couldn't read keypair file");
    let receiver = Pubkey::from_str(RECEIVER_ADDR)?;

    let (sig, mint_pubkey) = prepare_mint(
        &client,
        &funder,
        &receiver
    )?;

    println!("Finished prepare_mint...");
    println!("sig: {}, mint: {}", sig, mint_pubkey);

    mint_and_freeze(
        funder,
        &mint_pubkey,
        &receiver
    )?;

    Ok(())
}

pub fn mint_and_freeze(
    funder: Keypair,
    mint_pubkey: &Pubkey,
    receiver: &Pubkey
) -> Result<()> {
    let metaplex_program_id = Pubkey::from_str(METAPLEX_PROGRAM_ID)?;

    // Derive metadata account
    let metadata_seeds = &[
        "metadata".as_bytes(),
        &metaplex_program_id.to_bytes(),
        &mint_pubkey.to_bytes(),
    ];
    let (metadata_account, _pda) =
        Pubkey::find_program_address(metadata_seeds, &metaplex_program_id);

    // Derive Master Edition account
    // let master_edition_seeds = &[
    //     "metadata".as_bytes(),
    //     &metaplex_program_id.to_bytes(),
    //     &mint_pubkey.to_bytes(),
    //     "edition".as_bytes(),
    // ];
    // let (_master_edition_account, _pda) =
    //     Pubkey::find_program_address(master_edition_seeds, &metaplex_program_id);

    let funder_copy = Keypair::from_bytes(&funder.to_bytes())?;
    let anchor_client = Client::new(Cluster::Devnet, Rc::new(funder));
    let kycdao_ntnft_id = Pubkey::from_str(KYCDAO_PROGRAM_ID)?;
    let program = anchor_client.program(kycdao_ntnft_id);

    // Derive associated token account
    let token_account = get_associated_token_address(&receiver, &mint_pubkey);

    program
        .request()
        .signer(&funder_copy)
        .accounts(kycdao_ntnft_accounts::MintNFT {
            mint_authority: funder_copy.pubkey(),
            mint: *mint_pubkey,
            token_account: token_account,
            token_program: TOKEN_PROGRAM_ID,
            metadata: metadata_account,
            token_metadata_program: metaplex_program_id,
            payer: funder_copy.pubkey(),
            system_program: SYSTEM_PROGRAM_ID,
            rent: RENT_PUBKEY,
        })
        .args(kycdao_ntnft_instruction::MintAndFreezeNft { 
            creator_key: *receiver,
            uri: "https://arweave.net/y5e5DJsiwH0s_ayfMwYk-SnrZtVZzHLQDSTZ5dNRUHA".to_string(),
            title: "Frozen NFT from rust".to_string(), 
        })
        .send()?;  

    Ok(())
}

pub fn prepare_mint(
    client: &RpcClient,
    funder: &Keypair,
    receiver: &Pubkey,
) -> Result<(Signature, Pubkey)> {
    let mint = Keypair::new();

    // Allocate memory for the account
    let min_rent = client.get_minimum_balance_for_rent_exemption(MINT_LAYOUT as usize)?;

    // Create mint account
    let create_mint_account_ix = create_account(
        &funder.pubkey(),
        &mint.pubkey(),
        min_rent,
        MINT_LAYOUT,
        &TOKEN_PROGRAM_ID,
    );

    // Initalize mint ix
    let init_mint_ix = initialize_mint(
        &TOKEN_PROGRAM_ID,
        &mint.pubkey(),
        &funder.pubkey(),
        Some(&funder.pubkey()),
        0,
    )?;

    // Create associated account instruction
    let create_assoc_account_ix =
        create_associated_token_account(&funder.pubkey(), receiver, &mint.pubkey());

    let instructions = vec![
        create_mint_account_ix,
        init_mint_ix,
        create_assoc_account_ix
    ];

    let recent_blockhash = client.get_latest_blockhash()?;
    let tx = Transaction::new_signed_with_payer(
        &instructions,
        Some(&funder.pubkey()),
        &[&funder, &mint],
        recent_blockhash,
    );

    // Send tx with retries.
    let res = retry(
        Exponential::from_millis_with_factor(250, 2.0).take(3),
        || client.send_and_confirm_transaction(&tx),
    );
    let sig = res?;

    Ok((sig, mint.pubkey()))
}